---
name: languages
description: Master programming languages including JavaScript, TypeScript, Python, Go, Java, C++, Kotlin, PHP, Rust, Shell/Bash, and HTML. Build strong computer science fundamentals.
---

# Programming Languages & Fundamentals

## Quick Start

Choose your language journey:

```python
# Python - Data science, automation, AI
# JavaScript - Web frontend and backend
# Go - Cloud, microservices, CLI tools
# Java - Enterprise, Android
# C++ - Systems, performance, games
# Rust - Safe systems programming
```

## Programming Languages

### 1. JavaScript/ECMAScript
Essential for web development:
- **Modern Syntax**: ES6+, arrow functions, destructuring
- **Async Programming**: Promises, async/await
- **Functional Programming**: First-class functions, closures
- **DOM Manipulation**: Browser APIs
- **Event Loop**: Understanding concurrency
- **Module Systems**: ESM, CommonJS

**Use Cases**: Web development, Node.js backend, scripting

### 2. TypeScript
Superset of JavaScript with types:
- **Type System**: Interfaces, generics, unions
- **Advanced Types**: Conditional, mapped, utility types
- **Decorators**: Class and property metadata
- **Module System**: ES6 modules with types
- **Tooling**: TSC compiler, IDE support
- **Ecosystem**: TypeScript-first frameworks

**Use Cases**: Large-scale web applications, type-safe development

### 3. Python
Versatile, readable language:
- **Data Structures**: Lists, dicts, sets, tuples
- **OOP**: Classes, inheritance, polymorphism
- **Functional**: Lambda, map, filter, comprehensions
- **Modules**: Rich standard library
- **Virtual Environments**: Dependency isolation
- **Packages**: pip, conda ecosystems

**Use Cases**: Data science, machine learning, automation, scripting

### 4. Go (Golang)
Concurrent, efficient language:
- **Goroutines**: Lightweight concurrency
- **Channels**: Communication between goroutines
- **Interfaces**: Duck typing, composition
- **Fast Compilation**: Compile to binary
- **Standard Library**: Comprehensive built-ins
- **Cross-platform**: Compile to any OS

**Use Cases**: Microservices, cloud tools, CLI applications

### 5. Java
Enterprise-grade language:
- **OOP Principles**: Classes, inheritance, interfaces
- **JVM**: Runtime and garbage collection
- **Collections**: List, Set, Map frameworks
- **Exception Handling**: Try-catch, custom exceptions
- **Annotations**: Metadata programming
- **Streams**: Functional programming additions

**Use Cases**: Enterprise applications, Android development

### 6. C++ (Modern C++)
High-performance systems language:
- **Memory Management**: Pointers, smart pointers, RAII
- **STL (Standard Template Library)**: Containers, algorithms
- **OOP**: Classes, templates, inheritance
- **Generic Programming**: Templates, template metaprogramming
- **Modern C++**: C++17, C++20 features
- **Performance**: Direct hardware control

**Use Cases**: Systems programming, games, performance-critical code

### 7. Rust
Safe systems programming language:
- **Ownership System**: Memory safety without GC
- **Borrowing & Lifetimes**: Compile-time guarantees
- **Pattern Matching**: Powerful control flow
- **Trait System**: Interface/behavior abstraction
- **Macros**: Metaprogramming capabilities
- **No Runtime**: Efficient execution

**Use Cases**: Systems programming, WebAssembly, security-critical code

### 8. PHP
Server-side web language:
- **Syntax**: Forgiving, easy to learn
- **Web-focused**: Built-in HTTP support
- **Namespaces**: Organize code into modules
- **OOP**: Classes, interfaces, traits
- **Sessions & Cookies**: Built-in web state
- **Database**: Easy connection and querying

**Use Cases**: Web development, content management systems

### 9. Kotlin
Modern JVM language:
- **Null Safety**: Eliminate null pointer exceptions
- **Extension Functions**: Add methods to existing classes
- **Coroutines**: Lightweight concurrency
- **Data Classes**: Boilerplate reduction
- **Functional Programming**: Lambda, higher-order functions
- **Interoperability**: Full Java compatibility

**Use Cases**: Android development, JVM applications

### 10. Bash/Shell Scripting
System automation and scripting:
- **Commands**: Pipeline operations, utilities
- **Variables**: Environment and user-defined
- **Control Flow**: Conditionals, loops, functions
- **File Operations**: Reading, writing, manipulation
- **Text Processing**: grep, sed, awk
- **System Administration**: Task automation

**Use Cases**: DevOps, automation, system administration

### 11. HTML
Markup language for web:
- **Semantic Elements**: Proper HTML5 structure
- **Forms**: Input validation, submission
- **Accessibility**: ARIA attributes, semantic markup
- **Microdata**: Structured data markup
- **Meta Tags**: SEO, social sharing
- **Web APIs**: Canvas, Web Workers, Storage

**Use Cases**: Web content, foundations for web development

## Computer Science Fundamentals

### Data Structures
Essential building blocks:
- **Arrays & Linked Lists**: Sequential data storage
- **Stacks & Queues**: LIFO and FIFO patterns
- **Trees**: Binary, balanced, search trees
- **Graphs**: Directed, undirected, weighted
- **Hash Tables**: Efficient lookups and storage
- **Heaps**: Priority queues, heap sort
- **Advanced**: Tries, segment trees, disjoint sets

### Algorithms
Problem-solving techniques:
- **Sorting**: Bubble, merge, quick, heap sort
- **Searching**: Linear, binary search
- **Graph**: DFS, BFS, Dijkstra, A*
- **Dynamic Programming**: Memoization, tabulation
- **Greedy**: Huffman coding, activity selection
- **String**: Pattern matching, compression
- **Math**: Fibonacci, factorials, combinatorics

### Algorithm Complexity
Analyze and optimize:
- **Big O Notation**: Time and space complexity
- **Analysis Techniques**: Master theorem, recurrence
- **Common Classes**: O(1), O(log n), O(n), O(n log n), O(nÂ²)
- **Optimization**: Reduce redundant calculations
- **Trade-offs**: Space vs time considerations

### Problem-Solving Patterns
Approach programming challenges:
- **Brute Force**: Complete enumeration
- **Divide and Conquer**: Breaking into subproblems
- **Sliding Window**: Efficient subarray operations
- **Two Pointers**: Linear time pair finding
- **Dynamic Programming**: Optimal substructure
- **Greedy**: Local optimal choices
- **Backtracking**: Exhaustive search with pruning

## Learning Paths

### Single Language Path
1. Language fundamentals
2. Data structures and algorithms
3. Standard library mastery
4. Advanced features and patterns
5. Real-world projects and optimization

### Polyglot Path
1. Master 3-4 languages with different paradigms
2. Understand language design principles
3. Learn when to use each language
4. Build cross-language projects
5. Study language implementation

### Systems Programming Path
1. C++ or Rust fundamentals
2. Memory management deep dive
3. Low-level operations
4. Performance profiling
5. Systems architecture projects

### Web Development Path
1. JavaScript fundamentals
2. Either TypeScript or Python
3. HTML and CSS
4. Chosen framework (React, Vue, Django)
5. Full-stack application

## Algorithm Practice Categories

### Array Problems
- Array manipulation and searching
- Two-pointer techniques
- Sliding window patterns
- Subarrays and subsequences

### Tree Problems
- Tree traversals (inorder, preorder, postorder)
- BST operations
- Balanced tree concepts
- Common tree patterns

### Graph Problems
- Graph traversals (BFS, DFS)
- Shortest path algorithms
- Topological sorting
- Strongly connected components

### Dynamic Programming
- Memoization and tabulation
- Optimal substructure identification
- State definition
- Transition formulation

### String Algorithms
- Pattern matching (KMP, Boyer-Moore)
- Anagram problems
- Palindromes and editorials
- String compression

## Resources

### Practice Platforms
- LeetCode: Algorithm problems
- HackerRank: Multi-language practice
- Codewars: Ranked challenges
- Project Euler: Mathematical programming
- Advent of Code: Seasonal challenges

### Learning Resources
- Language official documentation
- "Clean Code" by Robert Martin
- "Algorithms" by Sedgewick & Wayne
- Online course platforms (Udemy, Coursera)
- YouTube tutorials

## Best Practices

- Write clean, readable code
- Follow language conventions and idioms
- Understand standard library thoroughly
- Practice consistent naming conventions
- Comment complex logic, not obvious code
- Write tests alongside code
- Refactor regularly
- Learn language history and design
- Contribute to open source
- Build real projects
